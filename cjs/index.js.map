{"version":3,"file":"index.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACNA;;;ACAA;;AACA;AACA;AACA;AACA;AACA;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;;AA3CA;;AA6CA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AACA;AACA;AACA;;AApBA;;AAsBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AAEA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;;;;AC7JA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;;AAKA;AACA;AACA;AACA;;AACA;;AAIA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAYA;AACA;AACA;AAAA;AAAA;;AACA;AACA;;AAEA;;AAGA;AACA;;AACA;AACA;AACA;;AACA;AAAA;;AACA;AACA;AACA;;AACA;AAAA;;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AAEA;;;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;;AACA;AACA;AAEA;AAEA;AACA;;AAEA;;AAEA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AACA;AACA;AAKA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAIA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAPA;AAbA;AAuBA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AALA;AAaA;;ACpNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AAFA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AADA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;;ACjCA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAVA;AAYA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AAIA;AACA;AACA;AACA;AACA;;AALA;AASA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAAA;AAAA;AACA;AACA;AACA;;AAVA;AAcA;AACA;AACA","sources":["webpack://PropsValidator/webpack/universalModuleDefinition","webpack://PropsValidator/webpack/bootstrap","webpack://PropsValidator/webpack/runtime/compat get default export","webpack://PropsValidator/webpack/runtime/define property getters","webpack://PropsValidator/webpack/runtime/hasOwnProperty shorthand","webpack://PropsValidator/webpack/runtime/make namespace object","webpack://PropsValidator/external commonjs2 \"prop-types\"","webpack://PropsValidator/./dist/Env/index.js","webpack://PropsValidator/./dist/Error/index.js","webpack://PropsValidator/./dist/util.js","webpack://PropsValidator/./dist/AutoFactory/index.js","webpack://PropsValidator/./dist/ExtendProps/DateValidator.js","webpack://PropsValidator/./dist/ExtendProps/TypedArray.js","webpack://PropsValidator/./dist/ExtendProps/Nullly.js","webpack://PropsValidator/./dist/ExtendProps/Promise.js","webpack://PropsValidator/./dist/ExtendProps/index.js","webpack://PropsValidator/./dist/UtilExtends/Promise.js","webpack://PropsValidator/./dist/UtilExtends/WrapperApi.js","webpack://PropsValidator/./dist/UtilExtends/index.js","webpack://PropsValidator/./dist/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PropsValidator\"] = factory();\n\telse\n\t\troot[\"PropsValidator\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"prop-types\");","let isProduction = () => true;\r\nfunction initEnv(option) {\r\n    isProduction = () => {\r\n        return option.env === 'production';\r\n    };\r\n}\r\nexport { isProduction, initEnv, };\r\n","class ValidatorError extends Error {\r\n    struct = {\r\n        propsName: \"\",\r\n        value: undefined,\r\n        expectedType: \"\",\r\n        preciseType: \"\"\r\n    };\r\n    name = 'ValidatorError';\r\n    propsName;\r\n    info;\r\n    value;\r\n    constructor(msg, propsName, info, value) {\r\n        super(msg);\r\n        this.propsName = propsName;\r\n        this.info = info;\r\n        this.value = value;\r\n    }\r\n    toString() {\r\n        let struct;\r\n        if (this.info instanceof ObjectValidatorError || this.info instanceof ValidatorError) {\r\n            this.struct = { propsName: this.info.propsName, value: '', expectedType: '', preciseType: '' };\r\n            return this.info.toString();\r\n        }\r\n        else if (this.info instanceof Error) {\r\n            // eslint-disable-next-line no-useless-escape\r\n            const data = this.info.message.match(/(?<=(`))([\\[\\]\\w<>\\d\\.]+)(?=(`))/g);\r\n            if (data) {\r\n                const [propsName, preciseType, value, expectedType] = data;\r\n                struct = { propsName, value, expectedType, preciseType };\r\n            }\r\n            else {\r\n                //this.info.message \r\n                return this.info.message;\r\n                // struct = { propsName: 'ValidatorError 解析值错误', value: '', expectedType: '', preciseType: '' }\r\n            }\r\n        }\r\n        else {\r\n            struct = this.info;\r\n        }\r\n        this.struct = struct;\r\n        const { propsName, value, expectedType, preciseType } = struct;\r\n        //this.value ??\r\n        return `属性:[${propsName}]的值等于['${value}'],期待为 ${expectedType} 类型/值，实际类型/值： ${preciseType} .`;\r\n    }\r\n}\r\nclass ObjectValidatorError extends Error {\r\n    name = 'ObjectValidatorError';\r\n    source = [];\r\n    propsName;\r\n    constructor(msg, propsName, error) {\r\n        super(msg);\r\n        this.source = error;\r\n        this.propsName = propsName;\r\n    }\r\n    toString() {\r\n        // let result = `{${new Array(this.source.length).fill(0).map((_) => '\"$$\":\"$$\"').join(',')}}`;\r\n        const result = {};\r\n        this.source.forEach(item => {\r\n            const info = item.toString();\r\n            const { struct: { propsName } } = item;\r\n            // result = result.replace(`$$`, propName);\r\n            // result = result.replace(`$$`, info);\r\n            result[propsName] = info;\r\n        });\r\n        return result;\r\n    }\r\n}\r\nfunction flattenError(objectError) {\r\n    const result = {};\r\n    Object.keys(objectError).forEach(key => {\r\n        let value = objectError[key];\r\n        if (!!value === false)\r\n            return;\r\n        if (!(value instanceof ObjectValidatorError)) {\r\n            value = value instanceof ValidatorError ? value : new ValidatorError(`${key} 验证失败`, key, value);\r\n        }\r\n        result[key] = value.toString();\r\n    });\r\n    return JSON.stringify(result, null, 2);\r\n}\r\nfunction showDifferenceTable(typeSpecs, value, objectError) {\r\n    // console.log('object-validator:', error, value);\r\n    // const v_key = Object.keys(value);\r\n    // var languages = {\r\n    //   csharp: { name: \"C#\", paradigm: \"object-oriented\" },\r\n    //   fsharp: { name: \"F#\", paradigm: \"functional\" }\r\n    // };\r\n}\r\nexport { ValidatorError, ObjectValidatorError, flattenError, showDifferenceTable };\r\n","import { isProduction } from './Env';\r\nimport { flattenError, ObjectValidatorError, ValidatorError, showDifferenceTable } from './Error';\r\nconst toTypeString = Function.call.bind(Object.prototype.toString);\r\nconst ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\r\nconst validatorSymbol = Symbol.for('validatorDisplayName');\r\nconst has = Function.call.bind(Object.prototype.hasOwnProperty);\r\nfunction isSymbol(propType, propValue) {\r\n    if (propType === 'symbol')\r\n        return true;\r\n    if (!propValue)\r\n        return false;\r\n    if (propValue['@@toStringTag'] === 'Symbol')\r\n        return true;\r\n    if (typeof Symbol === 'function' && propValue instanceof Symbol)\r\n        return true;\r\n    return false;\r\n}\r\nfunction getPreciseType(propValue) {\r\n    if (typeof propValue === 'undefined' || propValue === null) {\r\n        return '' + propValue;\r\n    }\r\n    const propType = getPropType(propValue);\r\n    if (propType === 'object') {\r\n        if (propValue instanceof Date) {\r\n            return 'date';\r\n        }\r\n        else if (propValue instanceof RegExp) {\r\n            return 'regexp';\r\n        }\r\n    }\r\n    return propType;\r\n}\r\nfunction getPropType(propValue) {\r\n    const propType = typeof propValue;\r\n    if (Array.isArray(propValue))\r\n        return 'array';\r\n    if (propValue instanceof RegExp)\r\n        return 'object';\r\n    if (isSymbol(propType, propValue))\r\n        return 'symbol';\r\n    return propType;\r\n}\r\nfunction createChainableTypeChecker(validate) {\r\n    function checkType(isRequired, props, propName, c, l, propFullName) {\r\n        propFullName = propFullName || propName;\r\n        if (props[propName] == null) {\r\n            if (isRequired) {\r\n                return wrapperError(propName, props[propName], '非空', 'null/undefined');\r\n            }\r\n            return null;\r\n        }\r\n        else {\r\n            return validate(props, propName, c, l, propFullName);\r\n        }\r\n    }\r\n    const chainedCheckType = checkType.bind(null, false);\r\n    chainedCheckType.isRequired = checkType.bind(null, true);\r\n    return chainedCheckType;\r\n}\r\nfunction wrapperError(propsName, value, expectedType, preciseType) {\r\n    return new ValidatorError(`${propsName} 验证失败`, propsName, {\r\n        propsName,\r\n        value,\r\n        expectedType,\r\n        preciseType\r\n    });\r\n}\r\n/***\r\n * 验证属性类型 是否为给定的值\r\n * createExpectedTypeChecker('[object Array]')\r\n */\r\nfunction createExpectedTypeChecker(expectedType) {\r\n    function validate(props, propName) {\r\n        const propValue = props[propName];\r\n        const propType = toTypeString(propValue);\r\n        if (propType !== expectedType) {\r\n            const preciseType = getPreciseType(propValue);\r\n            return wrapperError(propName, propValue, expectedType, preciseType);\r\n        }\r\n        return null;\r\n    }\r\n    return createChainableTypeChecker(validate);\r\n}\r\nfunction checkPropTypes(typeSpecs, values, showDifference = true) {\r\n    if (isProduction())\r\n        return null;\r\n    let objectError = {};\r\n    let error = null;\r\n    for (const typeSpecName in typeSpecs) {\r\n        if (typeSpecName === '__tag')\r\n            continue;\r\n        if (has(typeSpecs, typeSpecName)) {\r\n            try {\r\n                if (typeof typeSpecs[typeSpecName] !== 'function') {\r\n                    const err = Error('验证函数类型错误');\r\n                    err.name = 'Invariant Violation';\r\n                    throw err;\r\n                }\r\n                error = typeSpecs[typeSpecName](values, typeSpecName, '', '', null, ReactPropTypesSecret);\r\n                objectError[typeSpecName] = (!!error === false || error instanceof ObjectValidatorError) ? error : new ValidatorError(`${typeSpecName} 验证失败`, typeSpecName, error, values[typeSpecName]);\r\n            }\r\n            catch (ex) {\r\n                objectError = ex;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (Object.values(objectError).filter($1 => !!$1 === true).length > 0) {\r\n        if (showDifference)\r\n            showDifferenceTable(typeSpecs, values, objectError);\r\n        return new Error(flattenError(objectError));\r\n    }\r\n    return null;\r\n}\r\nfunction createArrayOfTypeChecker(typeChecker) {\r\n    function validate(props, propName, componentName, location, propFullName) {\r\n        const errors = [];\r\n        const propValue = props[propName];\r\n        if (!Array.isArray(propValue)) {\r\n            const propType = getPropType(propValue);\r\n            return wrapperError(propName, propValue, '[object Array]', propType);\r\n            // return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\r\n        }\r\n        for (let i = 0; i < propValue.length; i++) {\r\n            const error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\r\n            error && errors.push(new ValidatorError(`${propFullName} 验证失败`, propFullName, error, propValue));\r\n        }\r\n        return null;\r\n    }\r\n    return createChainableTypeChecker(validate);\r\n}\r\nfunction createShapeTypeChecker(shapeTypes) {\r\n    function validate(props, propName, componentName, location, propFullName) {\r\n        const errors = [];\r\n        const propValue = props[propName];\r\n        const propType = getPropType(propValue);\r\n        if (propType !== 'object') {\r\n            return wrapperError(propName, propValue, 'object', propType);\r\n        }\r\n        for (const key in shapeTypes) {\r\n            const checker = shapeTypes[key];\r\n            if (!checker) {\r\n                continue;\r\n            }\r\n            const error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\r\n            error && errors.push(new ValidatorError(`${propFullName} 验证失败`, propFullName, error, propValue));\r\n        }\r\n        if (errors.length > 0) {\r\n            const objError = new ObjectValidatorError(`验证错误：${propFullName}`, propFullName, errors);\r\n            return objError;\r\n        }\r\n        return null;\r\n    }\r\n    return createChainableTypeChecker(validate);\r\n}\r\nfunction validatorLog(_, typeSpec, msg) {\r\n    !isProduction() && console.log(`Validator Error。 [typeSpec.__tag]:[${typeSpec.__tag}] =>`, msg);\r\n}\r\nexport { validatorSymbol, toTypeString, getPropType, getPreciseType, createChainableTypeChecker, createExpectedTypeChecker, checkPropTypes, validatorLog, \r\n// .shape({})\r\ncreateShapeTypeChecker, \r\n//arrayOf\r\ncreateArrayOfTypeChecker,\r\n// .exact({})\r\n// createStrictShapeTypeChecker\r\n };\r\n","/* eslint-disable @typescript-eslint/no-unused-vars */\r\n/*\r\n * @Author: zihao.zhu@united-imaging.com\r\n * @Date: 2022-01-14 16:17:32\r\n * @Last Modified by: zihao.zhu\r\n * @Last Modified time: 2022-02-22 17:23:16\r\n * @desc : 用于自动生成propsType的验证器\r\n * 1:基础数据\r\n * 2:数组 / 对象 / typedArray\r\n * 3:函数\r\n * 4:复杂对象嵌套\r\n */\r\nimport { toTypeString } from \"../util\";\r\nimport { isProduction } from \"../Env\";\r\nconst PropsPlugin = {\r\n    extends: [],\r\n    getTypeSpec: () => \"{}\",\r\n    extendsFactory: () => { },\r\n};\r\nconst getType = (value) => {\r\n    const [_, target] = value.match(/\\[object (\\w+)\\]/) || [];\r\n    return target;\r\n};\r\nconst Wrapper = (type, topName) => [\r\n    `${topName}.${type}`,\r\n    `${topName}.${type}.isRequired`,\r\n];\r\nexport default function initAutoFactory(WsProps) {\r\n    if (!isProduction()) {\r\n        const DefaultOption = { maxDepth: 3, topName: \"WsPropsType\" };\r\n        const baseSource = [\r\n            null,\r\n            undefined,\r\n            1,\r\n            \"\",\r\n            false,\r\n            () => { },\r\n            Symbol.for(\"\"),\r\n            new Date(),\r\n            /\\w/,\r\n            Promise.resolve(),\r\n        ];\r\n        const seniorSource = [[], {}];\r\n        let typeArray = [];\r\n        const exec = { option: DefaultOption };\r\n        const getValidator = (type) => {\r\n            type = type.toLocaleLowerCase();\r\n            // var vaFunc = WsProps[type];\r\n            if (type === getType(toTypeString({})).toLocaleLowerCase())\r\n                type = \"shape($)\";\r\n            // if (!!vaFunc === false) type = 'any';\r\n            return Wrapper(type, exec.option.topName);\r\n        };\r\n        baseSource.forEach((item) => {\r\n            const objStr = toTypeString(item);\r\n            const minType = getType(objStr);\r\n            exec[`exec${minType}`] = function (props, value, isRequire = false) {\r\n                return (typeArray.find((item) => item.type === objStr)?.validator[Number(isRequire)] || \"\");\r\n            };\r\n        });\r\n        exec.execAny = function (props, value, isRequire = false) {\r\n            return (typeArray.find((item) => item.type === toTypeString(null))?.validator[Number(isRequire)] || \"\");\r\n        };\r\n        exec.execUnknown = function (props, value, isRequire = false) {\r\n            const objStr = toTypeString(value);\r\n            const info = typeArray.find((item) => item.type === objStr);\r\n            if (!!info === false) {\r\n                let minType = getType(objStr);\r\n                minType = minType.toLocaleLowerCase();\r\n                if (!!WsProps[minType] === true)\r\n                    return Wrapper(minType, exec.option.topName)[Number(isRequire)];\r\n            }\r\n            return exec.execAny(props, value, isRequire);\r\n        };\r\n        // exec.execUndefined = exec.execAny;\r\n        // exec.execNull = exec.execAny;\r\n        exec.execObject = function (props, target, isRequire = false, depth = 0, option) {\r\n            const objInfo = typeArray.find((item) => item.type === toTypeString({})) ||\r\n                {};\r\n            if (Object.keys(target).length === 0 || depth === option.maxDepth)\r\n                return Wrapper(objInfo.minType.toLocaleLowerCase(), exec.option.topName)[Number(isRequire)];\r\n            const result = {};\r\n            Object.keys(target).forEach((key) => {\r\n                const value = target[key];\r\n                const func = PropsPlugin.switchExec(value, key, target);\r\n                if (func && typeof func === typeof Function) {\r\n                    result[key] = func(props, value, isRequire, depth + 1, option);\r\n                }\r\n            });\r\n            if (depth === 0)\r\n                return result;\r\n            const { validator } = objInfo;\r\n            const template = validator[Number(isRequire)];\r\n            return template.replace(\"$\", JSON.stringify(result));\r\n        };\r\n        exec.execArray = function (props, value = [], isRequire = false, depth = 0, option) {\r\n            const sourceInfo = typeArray.find((item) => item.type === toTypeString([])) ||\r\n                {};\r\n            if (value.length === 0 || depth === option.maxDepth)\r\n                return sourceInfo.validator[Number(isRequire)];\r\n            const execFunc = PropsPlugin.switchExec(value[0]);\r\n            const validator = sourceInfo.validator[Number(false)];\r\n            //TODO:isRequire 是否直接给false\r\n            const result = `${validator}Of(${execFunc(props, value[0], false, depth + 1, option)})${isRequire ? \".isRequired\" : \"\"}`;\r\n            // const\r\n            return result;\r\n        };\r\n        PropsPlugin.switchExec = function switchExec(source, key, target) {\r\n            const type = typeArray.find((item) => item.type === toTypeString(source));\r\n            let execFunc = null;\r\n            const fName = type ? `exec${type.minType}` : null;\r\n            if (fName && !!exec[fName] === true) {\r\n                execFunc = exec[fName];\r\n            }\r\n            else {\r\n                const plugin = PropsPlugin.extends.find((item) => item.test(source));\r\n                if (plugin) {\r\n                    const { choice, execMap } = plugin;\r\n                    const execName = choice(source, key, target);\r\n                    execFunc = execMap[execName] || exec[execName];\r\n                }\r\n            }\r\n            return execFunc || exec.execAny;\r\n        };\r\n        PropsPlugin.installType = function (source, isRequire = false) {\r\n            typeArray = (function (target) {\r\n                return target.map((item) => {\r\n                    const targetType = toTypeString(item);\r\n                    const minType = getType(targetType);\r\n                    const validator = getValidator(minType);\r\n                    return { type: targetType, minType, validator };\r\n                });\r\n            })([...baseSource, ...seniorSource]);\r\n        };\r\n        PropsPlugin.extendsFactory = function (plugin) {\r\n            if (!!plugin.test &&\r\n                typeof plugin.test === \"function\" &&\r\n                !!plugin.choice &&\r\n                typeof plugin.choice === \"function\" &&\r\n                !!plugin.execMap) {\r\n                PropsPlugin.extends.unshift(plugin);\r\n            }\r\n        };\r\n        PropsPlugin.__getID = () => {\r\n            const IDS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\r\n            const IDL = IDS.length;\r\n            let UID = \"\";\r\n            for (let i = 0; i < 10; i++) {\r\n                UID += IDS.charAt(Math.floor(Math.random() * IDL));\r\n            }\r\n            return UID;\r\n        };\r\n        PropsPlugin.getTypeSpec = function (source, isRequire = true, option = DefaultOption) {\r\n            option = { ...DefaultOption, ...option };\r\n            exec.option = option;\r\n            PropsPlugin.installType();\r\n            const result = PropsPlugin.switchExec(source)(\"\", source, isRequire, 0, option);\r\n            typeof result === \"object\" &&\r\n                (result.__tag = `'${PropsPlugin.__getID()}'`);\r\n            return JSON.stringify(result, null, 2)\r\n                .replace(/\\n/g, \"\")\r\n                .replace(/\"/g, \"\")\r\n                .replace(/\\\\/g, \"\");\r\n        };\r\n        extendTypedArray(PropsPlugin);\r\n        extendBigInt(PropsPlugin);\r\n    }\r\n    WsProps.PropsPlugin = PropsPlugin;\r\n    return PropsPlugin;\r\n}\r\nfunction extendTypedArray(plugin) {\r\n    // 对typedArray 扩展\r\n    plugin.extendsFactory &&\r\n        plugin.extendsFactory({\r\n            test: (source) => {\r\n                const type = toTypeString(new ArrayBuffer(0));\r\n                const minType = getType(type);\r\n                if (source &&\r\n                    !!source.buffer &&\r\n                    Object.prototype.toString.call(source.buffer) === type)\r\n                    return true;\r\n                if (source && source.constructor && source.constructor.name === minType)\r\n                    return true;\r\n                return false;\r\n            },\r\n            choice: (props, propName, typeObject) => \"execTypedArray\",\r\n            execMap: {\r\n                execTypedArray: function (props, value, isRequire = false, depth = 0, option) {\r\n                    const type = toTypeString(value);\r\n                    const minType = getType(type)\r\n                        .toLocaleLowerCase()\r\n                        .replace(\"array\", \"\");\r\n                    return `${Wrapper(minType, option.topName)[Number(isRequire)]}`;\r\n                },\r\n            },\r\n        });\r\n}\r\nfunction extendBigInt(plugin) {\r\n    plugin.extendsFactory &&\r\n        plugin.extendsFactory({\r\n            test: (source) => {\r\n                return typeof source === typeof 1n;\r\n            },\r\n            choice: (props, propName, typeObject) => \"bigint\",\r\n            execMap: {\r\n                bigint: function (props, value, isRequire = false, depth = 0, option) {\r\n                    const type = toTypeString(value);\r\n                    const minType = getType(type).toLocaleLowerCase();\r\n                    return `${Wrapper(minType, option.topName)[Number(isRequire)]}`;\r\n                },\r\n            },\r\n        });\r\n}\r\n","/*\r\n * @Author: zihao.zhu@united-imaging.com\r\n * @Date: 2022-01-21 14:20:58\r\n * @Last Modified by:   zihao.zhu\r\n * @Last Modified time: 2022-01-21 14:20:58\r\n * @desc : date 验证\r\n */\r\nimport { createChainableTypeChecker, getPreciseType } from \"../util\";\r\n/**\r\n * date String '2021-11-11 00:00:00' 进行匹配\r\n * /(\\d){4}?-(\\d){2}?-(\\d){2}? (\\d){2}?:(\\d){2}?:(\\d){2}?/\r\n * @param regex\r\n * @returns\r\n */\r\nexport function dateValidatorCheckString(regex) {\r\n    function validate(props, propName) {\r\n        const propValue = props[propName];\r\n        if (regex && regex.test(propValue) === false) {\r\n            const preciseType = getPreciseType(propValue);\r\n            return new Error(`${JSON.stringify(props)}-[${propName}]-[${propValue}] is type ${preciseType} , but expected value is test(/^${regex}$/)`);\r\n        }\r\n        return null;\r\n    }\r\n    return createChainableTypeChecker(validate);\r\n}\r\n/**\r\n * 可以被解析成日期的值\r\n */\r\nexport const dateValidatorCheck = ((check) => {\r\n    function validate(props, propName) {\r\n        const propValue = props[propName];\r\n        if (check && !check(propValue)) {\r\n            const preciseType = getPreciseType(propValue);\r\n            return new Error(`${JSON.stringify(props)}-[${propName}]-[${propValue}] is type ${preciseType} , but expected value is test by Date.parse`);\r\n        }\r\n        return null;\r\n    }\r\n    return createChainableTypeChecker(validate);\r\n})((data) => {\r\n    const date = Date.parse(data);\r\n    return typeof date === 'number' && !isNaN(date) && date > 0;\r\n});\r\n","/*\r\n * @Author: zihao.zhu@united-imaging.com\r\n * @Date: 2022-01-21 14:21:35\r\n * @Last Modified by:   zihao.zhu\r\n * @Last Modified time: 2022-01-21 14:21:35\r\n * @desc : typedArray\r\n */\r\n/* eslint-disable  */\r\nimport { createExpectedTypeChecker, toTypeString } from \"../util\";\r\nexport default {\r\n    buffer: createExpectedTypeChecker(toTypeString(new ArrayBuffer(0))),\r\n    dataview: createExpectedTypeChecker(toTypeString(new DataView(new ArrayBuffer(0)))),\r\n    uint8: createExpectedTypeChecker(toTypeString(new Uint8Array())),\r\n    uint16: createExpectedTypeChecker(toTypeString(new Uint16Array())),\r\n    uint32: createExpectedTypeChecker(toTypeString(new Uint32Array())),\r\n    int8: createExpectedTypeChecker(toTypeString(new Int8Array())),\r\n    int16: createExpectedTypeChecker(toTypeString(new Int16Array())),\r\n    int32: createExpectedTypeChecker(toTypeString(new Int32Array())),\r\n    float32: createExpectedTypeChecker(toTypeString(new Float32Array())),\r\n    float64: createExpectedTypeChecker(toTypeString(new Float64Array())),\r\n    uint8clamped: createExpectedTypeChecker(toTypeString(new Uint8ClampedArray())),\r\n};\r\n","/*\r\n * @Author: zihao.zhu@united-imaging.com\r\n * @Date: 2022-01-21 14:21:10\r\n * @Last Modified by:   zihao.zhu\r\n * @Last Modified time: 2022-01-21 14:21:10\r\n * @desc : undefined / null\r\n */\r\n/* eslint-disable */\r\nimport { getPreciseType, toTypeString } from \"../util\";\r\nfunction createNullUndefinedTypeChecker(validate) {\r\n    function checkType(isRequired, props, propName) {\r\n        const value = props[propName];\r\n        if (value === null || value === undefined) {\r\n            return validate(props, propName);\r\n        }\r\n        else {\r\n            if (isRequired) {\r\n                return new Error(`The \\`${propName}\\` is null/Undefined as required , but its value is ${toTypeString(value)}`);\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n    const chainedCheckType = checkType.bind(null, false);\r\n    chainedCheckType.isRequired = checkType.bind(null, true);\r\n    return chainedCheckType;\r\n}\r\nfunction createExpectedTypeChecker(expectedType) {\r\n    function validate(props, propName) {\r\n        const propValue = props[propName];\r\n        const propType = toTypeString(propValue);\r\n        if (propType !== expectedType) {\r\n            const preciseType = getPreciseType(propValue);\r\n            return new Error(`Invalid ${propName} value is ${propValue} ,but expected ${expectedType} but get ${preciseType}`);\r\n        }\r\n        return null;\r\n    }\r\n    return createNullUndefinedTypeChecker(validate);\r\n}\r\nexport default {\r\n    null: createExpectedTypeChecker(toTypeString(null)),\r\n    undefined: createExpectedTypeChecker(toTypeString(undefined)),\r\n};\r\n","/*\r\n * @Author: zihao.zhu@united-imaging.com\r\n * @Date: 2022-01-21 14:21:29\r\n * @Last Modified by:   zihao.zhu\r\n * @Last Modified time: 2022-01-21 14:21:29\r\n * @desc : promise\r\n */\r\n/* eslint-disable */\r\nimport { createExpectedTypeChecker, toTypeString } from \"../util\";\r\nexport default {\r\n    promise: createExpectedTypeChecker(toTypeString(new Promise(() => { }))),\r\n};\r\n","/* eslint-disable  */\r\nimport { dateValidatorCheckString, dateValidatorCheck } from \"./DateValidator\";\r\nimport TypedArray from \"./TypedArray\";\r\nimport Null from \"./Nullly\";\r\nimport PromiseProps from \"./Promise\";\r\nexport default {\r\n    dateString: dateValidatorCheckString(/(\\d){4}?-(\\d){2}?-(\\d){2}? (\\d){2}?:(\\d){2}?:(\\d){2}?/),\r\n    date: dateValidatorCheck,\r\n    ...TypedArray,\r\n    ...Null,\r\n    ...PromiseProps,\r\n};\r\n","/*\r\n * @Author: zihao.zhu@united-imaging.com\r\n * @Date: 2022-01-21 14:20:23\r\n * @Last Modified by: zihao.zhu\r\n * @Last Modified time: 2022-01-21 16:54:32\r\n * @desc : Promise 验证\r\n */\r\n/* eslint-disable no-extra-boolean-cast */\r\nimport { checkPropTypes } from '../util';\r\nimport { validatorLog } from \"../util\";\r\nimport { isProduction } from \"../Env\";\r\n(function (prototype) {\r\n    if (!!prototype.validator)\r\n        return;\r\n    prototype.validator = function (typeSpec, handle) {\r\n        if (!isProduction()) {\r\n            const nextHandle = (source) => {\r\n                const result = !!handle ? handle(source) : source;\r\n                const error = checkPropTypes(typeSpec, result);\r\n                if (typeof source === 'object' && source !== null) {\r\n                    Object.defineProperty(source, '__props__error', {\r\n                        configurable: false,\r\n                        enumerable: false,\r\n                        get: () => error,\r\n                    });\r\n                }\r\n                error && validatorLog && validatorLog(source, typeSpec, error);\r\n                return source;\r\n            };\r\n            return this.then(nextHandle);\r\n        }\r\n        return this.then((data) => data);\r\n    };\r\n})((window || this).Promise.prototype);\r\n","import { isProduction } from \"../Env\";\r\nexport default function WrapperApi(Api, spec) {\r\n    if (isProduction())\r\n        Api;\r\n    const createProxy = (api, specSource) => {\r\n        Object.keys(api).forEach(key => {\r\n            const target = api[key];\r\n            if (typeof target === 'object') {\r\n                let spec = specSource && specSource[key];\r\n                if (typeof spec !== 'object')\r\n                    spec = {};\r\n                api[key] = createProxy(target, spec);\r\n            }\r\n        });\r\n        return new Proxy(api, {\r\n            get(target, key) {\r\n                const source = target[key];\r\n                if (typeof source === 'function') {\r\n                    const spec = ((specSource && specSource[key]) || {});\r\n                    return (...args) => {\r\n                        return source(...args).validator(spec.spec, spec.handler);\r\n                    };\r\n                }\r\n                return target[key];\r\n            }\r\n        });\r\n    };\r\n    return createProxy(Api, spec);\r\n    // const keys = Object.keys(Api);\r\n    // const newApi = {};\r\n    // keys.forEach((key) => {\r\n    //   const module = Api[key];\r\n    //   const moduleSpec = SpecSpace.default[key];\r\n    //   newApi[key] = new Proxy(module, {\r\n    //     get(target, propKey) {\r\n    //       const exec = target[propKey];\r\n    //       const spec = moduleSpec[propKey as string];\r\n    //       if (typeof exec === 'function' && typeof spec === 'object') {\r\n    //         return (...args) => {\r\n    //           return (exec(...args) as PromiseExtends<any>).validator(spec.spec, spec.handler);\r\n    //         }\r\n    //       }\r\n    //       return exec;\r\n    //     }\r\n    //   })\r\n    // })\r\n    // return newApi;\r\n}\r\n","import './Promise';\r\nimport WrapperApi from './WrapperApi';\r\nexport { WrapperApi };\r\n","/*\r\n * @Author: zihao.zhu@united-imaging.com\r\n * @Date: 2022-01-21 14:19:46\r\n * @Last Modified by: zihao.zhu\r\n * @Last Modified time: 2022-02-22 16:08:41\r\n * @desc : 类型声明和验证\r\n */\r\n/* eslint-disable @typescript-eslint/no-redeclare */\r\nimport PropTypes from \"prop-types\";\r\nimport initAutoFactory from \"./AutoFactory\";\r\nimport { initEnv } from \"./Env\";\r\nimport ExtendsValidator from \"./ExtendProps\";\r\nimport { createChainableTypeChecker, checkPropTypes, createExpectedTypeChecker, validatorLog, validatorSymbol, createShapeTypeChecker, createArrayOfTypeChecker, } from \"./util\";\r\nimport { WrapperApi } from \"./UtilExtends/index\";\r\nexport var RunEnv;\r\n(function (RunEnv) {\r\n    RunEnv[\"dev\"] = \"development\";\r\n    RunEnv[\"prod\"] = \"production\";\r\n})(RunEnv || (RunEnv = {}));\r\nconst WsPropsType = { env: RunEnv.dev };\r\nfunction initValidator(source) {\r\n    if (!Array.isArray(source))\r\n        source = [source];\r\n    source.forEach((item) => Object.getOwnPropertyNames(item).forEach((key) => {\r\n        const target = item[key];\r\n        target[validatorSymbol] = key;\r\n        WsPropsType[key] = target;\r\n    }));\r\n}\r\nfunction extendsValidator(name, validator) {\r\n    WsPropsType[name] = createChainableTypeChecker(validator);\r\n}\r\ninitValidator([\r\n    PropTypes,\r\n    ExtendsValidator,\r\n    {\r\n        checkPropTypes,\r\n        boolean: PropTypes.bool,\r\n        function: PropTypes.func,\r\n        shape: createShapeTypeChecker,\r\n        arrayOf: createArrayOfTypeChecker,\r\n        // exact: createStrictShapeTypeChecker,\r\n    },\r\n    {\r\n        extendsValidator,\r\n        util: {\r\n            createChainableTypeChecker,\r\n            createExpectedTypeChecker,\r\n            validatorLog,\r\n        },\r\n        apiUtil: { WrapperApi },\r\n        setEnv: (env) => {\r\n            WsPropsType.env = env;\r\n        },\r\n        // PropsPlugin,\r\n    },\r\n]);\r\ninitEnv(WsPropsType);\r\ninitAutoFactory(WsPropsType);\r\nexport default WsPropsType;\r\n"],"names":[],"sourceRoot":""}